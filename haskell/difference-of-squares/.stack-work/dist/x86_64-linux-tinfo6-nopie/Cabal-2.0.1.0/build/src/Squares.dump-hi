
==================== FINAL INTERFACE ====================
2018-04-30 19:26:55.468119753 UTC

interface difference-of-squares-1.2.0.5-K6CIzEi1QIe92TVYW1hIrL:Squares 8022
  interface hash: af4d4880feb21e88a0e32d58c83ca98f
  ABI hash: a6e630f6bf2c4e3eab9bbe01e0a2ca6d
  export-list hash: 7524d1236e5c87de13f98b88ec4dc248
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 26e0ff4b0ff758fc4ebf6a516aed248e
  sig of: Nothing
  used TH splices: False
  where
exports:
  Squares.difference
  Squares.squareOfSums
  Squares.sumOfSquares
module dependencies:
package dependencies: base-4.10.1.0* ghc-prim-0.5.1.1
                      integer-gmp-1.0.1.0
orphans: base-4.10.1.0:GHC.Float base-4.10.1.0:GHC.Base
family instance modules: base-4.10.1.0:Control.Applicative
                         base-4.10.1.0:Data.Either base-4.10.1.0:Data.Functor.Const
                         base-4.10.1.0:Data.Functor.Identity base-4.10.1.0:Data.Monoid
                         base-4.10.1.0:Data.Type.Equality base-4.10.1.0:GHC.Generics
                         base-4.10.1.0:GHC.IO.Exception base-4.10.1.0:GHC.TypeLits
                         base-4.10.1.0:GHC.TypeNats
import  -/  base-4.10.1.0:Data.Foldable 9ed87455d68e87ff2b5b8725eae9897e
import  -/  base-4.10.1.0:GHC.Base 782fd99b5e36f3698a26179a49afca64
import  -/  base-4.10.1.0:GHC.Num 6e1dc5d36d99a802edb39b92bb1923b8
import  -/  base-4.10.1.0:GHC.Real 3c62834bc25e762eabc44149c4cc142d
import  -/  base-4.10.1.0:Prelude 31945b7d0084063347fc52506d3a4020
8728ab793ebed263860f2dc713ed5fbc
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Squares.$trModule3
                   Squares.$trModule1) -}
3a74f96064874d8d93298de8af4cd6b1
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Squares.$trModule2) -}
0c1ee045bb1de00a0611275ce6b07ff8
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Squares"#) -}
95c3073488f832bb34e27b5e69327ffe
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Squares.$trModule4) -}
bc5d153dbc725eff7f05e9c838f080d8
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("difference-of-squares-1.2.0.5-K6CIzEi1QIe92TVYW1hIrL"#) -}
e364c3301c4ac478be582a82144b9251
  difference :: GHC.Real.Integral a => a -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S(LC(C(S))LLLLL)LL)LLLLLLLL),U(U(U(C(C1(U)),1*C1(C1(U)),C(C1(U)),A,A,A,C(U)),A,A),U(A,A,A,A,A,A,C(C1(U)),A),A,A,A,A,A,A,A)><L,U>,
     Unfolding: (\ @ a ($dIntegral :: GHC.Real.Integral a) (eta :: a) ->
                 GHC.Num.-
                   @ a
                   (GHC.Real.$p1Real @ a (GHC.Real.$p1Integral @ a $dIntegral))
                   (Squares.squareOfSums @ a $dIntegral eta)
                   (Squares.sumOfSquares @ a $dIntegral eta)) -}
38bc637d7650360ea235b4071935a8af
  squareOfSums :: GHC.Real.Integral a => a -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S(LLC(C(S))LLLL)LL)LLLLLLLL),U(1*U(1*U(C(C1(U)),A,1*C1(C1(U)),A,A,A,C(U)),A,A),1*U(A,A,A,A,A,A,1*C1(C1(U)),A),A,A,A,A,A,A,A)><L,U>,
     Unfolding: (\ @ a ($dIntegral :: GHC.Real.Integral a) (eta :: a) ->
                 let {
                   $dReal :: GHC.Real.Real a = GHC.Real.$p1Integral @ a $dIntegral
                 } in
                 let {
                   $dNum :: GHC.Num.Num a = GHC.Real.$p1Real @ a $dReal
                 } in
                 let {
                   x :: a
                   = letrec {
                       go :: [a] -> a -> a
                         <join 2> {- Arity: 2, Strictness: <S,1*U><L,U> -}
                       = \ (ds :: [a]) (eta1 :: a) ->
                         case ds of wild {
                           [] -> eta1 : y ys -> go ys (GHC.Num.+ @ a $dNum eta1 y) }
                     } in
                     go
                       (GHC.Enum.enumFromTo
                          @ a
                          (GHC.Real.$p2Integral @ a $dIntegral)
                          (GHC.Num.fromInteger @ a $dNum Squares.sumOfSquares2)
                          eta)
                       (GHC.Num.fromInteger @ a $dNum Squares.sumOfSquares1)
                 } in
                 GHC.Num.* @ a $dNum x x) -}
8de860bf0f3d4bb188b5646e711b0c9b
  sumOfSquares :: GHC.Real.Integral a => a -> a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LS(LLLLLLC(C(S))L)LLLLLLL),U(1*U(1*U(C(C1(U)),A,C(C1(U)),A,A,A,C(U)),A,A),1*U(A,A,A,A,A,A,1*C1(C1(U)),A),A,A,A,A,A,A,A)><L,U>,
     Unfolding: (\ @ a ($dIntegral :: GHC.Real.Integral a) (eta :: a) ->
                 let {
                   $dReal :: GHC.Real.Real a = GHC.Real.$p1Integral @ a $dIntegral
                 } in
                 let {
                   $dNum :: GHC.Num.Num a = GHC.Real.$p1Real @ a $dReal
                 } in
                 letrec {
                   go :: [a] -> a -> a
                     <join 2> {- Arity: 2, Strictness: <S,1*U><L,U> -}
                   = \ (ds :: [a]) (eta1 :: a) ->
                     case ds of wild {
                       [] -> eta1
                       : y ys
                       -> go ys (GHC.Num.+ @ a $dNum eta1 (GHC.Num.* @ a $dNum y y)) }
                 } in
                 go
                   (GHC.Enum.enumFromTo
                      @ a
                      (GHC.Real.$p2Integral @ a $dIntegral)
                      (GHC.Num.fromInteger @ a $dNum Squares.sumOfSquares2)
                      eta)
                   (GHC.Num.fromInteger @ a $dNum Squares.sumOfSquares1)) -}
1521b867ed5b36d8a1d24d028658ac60
  sumOfSquares1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (0) -}
b749dd2300b2b44431d8ae34c8165ba2
  sumOfSquares2 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (1) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

