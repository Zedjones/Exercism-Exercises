
==================== FINAL INTERFACE ====================
2018-04-28 05:18:06.092774305 UTC

interface bob-1.2.0.5-1GDXlu5OfNGJeDySZFLtOX:Bob 8022
  interface hash: d36dc43b14bbbabb494c3b4a11930e61
  ABI hash: 73688e139dff8b4f463b363ecd567138
  export-list hash: b13b080fc9f2b20167f3323c9a0bbe3c
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 26e0ff4b0ff758fc4ebf6a516aed248e
  sig of: Nothing
  used TH splices: False
  where
exports:
  Bob.main
  Bob.responseFor
module dependencies:
package dependencies: base-4.10.1.0* ghc-prim-0.5.1.1
                      integer-gmp-1.0.1.0
orphans: base-4.10.1.0:GHC.Float base-4.10.1.0:GHC.Base
family instance modules: base-4.10.1.0:Control.Applicative
                         base-4.10.1.0:Data.Either base-4.10.1.0:Data.Functor.Const
                         base-4.10.1.0:Data.Functor.Identity base-4.10.1.0:Data.Monoid
                         base-4.10.1.0:Data.Type.Equality base-4.10.1.0:GHC.Generics
                         base-4.10.1.0:GHC.IO.Exception base-4.10.1.0:GHC.TypeLits
                         base-4.10.1.0:GHC.TypeNats
import  -/  base-4.10.1.0:Data.Char fe4e3458190deeac19969ce15e33bed9
import  -/  base-4.10.1.0:Data.Foldable 9ed87455d68e87ff2b5b8725eae9897e
import  -/  base-4.10.1.0:GHC.Base 782fd99b5e36f3698a26179a49afca64
import  -/  base-4.10.1.0:GHC.List e3060fbeb44ce0038e6b4dedf2dd9cf1
import  -/  base-4.10.1.0:GHC.Unicode 49c9de4fffed0d9be65aaeb6a60b757c
import  -/  base-4.10.1.0:Prelude 31945b7d0084063347fc52506d3a4020
import  -/  base-4.10.1.0:System.IO 6e5bb580370d8d71dc5888f723cea4b4
import  -/  ghc-prim-0.5.1.1:GHC.Classes 93e2660065dce9329577e83d76d8f0d4
ece696a73eac06d4bceb29dbc5b5741c
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Bob.$trModule3 Bob.$trModule1) -}
2d2dd36af7541907e416f4bdbe272a9f
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Bob.$trModule2) -}
5b05996663e84d012b81914a6949f434
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Bob"#) -}
8060c76271177ad30d18b98a0875e3d7
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Bob.$trModule4) -}
5678d63c70a34b85b9359259bc5b866b
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("bob-1.2.0.5-1GDXlu5OfNGJeDySZFLtOX"#) -}
374f53a5a4f25de6a7f32fb48dc86d83
  main :: GHC.Types.IO ()
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Bob.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R)) -}
8ca9795754799ce1430980fab7f0e976
  main1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1,
     Unfolding: (GHC.IO.Handle.Text.hPutStr2
                   GHC.IO.Handle.FD.stdout
                   Bob.main2
                   GHC.Types.True) -}
12ca420dad8491b663d8904625b4e35a
  main2 :: GHC.Base.String
  {- Unfolding: (case Bob.main3
                        (GHC.List.lastError @ GHC.Types.Char) of wild { GHC.Types.C# x ->
                 case x of wild1 {
                   DEFAULT -> GHC.Show.$fShowBool3
                   '?'# -> GHC.Show.$fShowBool1 } }) -}
3b05f306377d17a63fdee5cf76c76e9e
  main3 :: GHC.Types.Char -> GHC.Types.Char
  {- Unfolding: (GHC.CString.unpackFoldrCString#
                   @ (GHC.Types.Char -> GHC.Types.Char)
                   Bob.main5
                   Bob.main4
                   (GHC.Base.id @ GHC.Types.Char)) -}
b65fe466e9910f556964b13f14939468
  main4 ::
    GHC.Types.Char
    -> (GHC.Types.Char -> GHC.Types.Char)
    -> GHC.Types.Char
    -> GHC.Types.Char
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><C(S),1*C1(U(U))><L,A>,
     Unfolding: (\ (ds :: GHC.Types.Char)
                   (ds1 :: GHC.Types.Char -> GHC.Types.Char)[OneShot]
                   (v :: GHC.Types.Char)[OneShot] ->
                 ds1 ds) -}
25e9fc8d9bb65b0110340341bc00696d
  main5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Ending with ? means a question."#) -}
59d33186cbb04e6a1df33189d0229e08
  responseFor :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (xs :: GHC.Base.String) ->
                 let {
                   $j :: [GHC.Types.Char] <join 0>
                   = let {
                       $j1 :: [GHC.Types.Char] <join 0>
                       = let {
                           $j2 :: [GHC.Types.Char] <join 0>
                           = Bob.responseFor_go1
                               (Bob.strip xs)
                               (GHC.List.lastError @ GHC.Types.Char)
                         } in
                         case (Bob.responseFor_go xs)
                                `cast`
                              (Data.Monoid.N:All[0]) of wild {
                           GHC.Types.False -> $j2
                           GHC.Types.True
                           -> letrec {
                                go :: [GHC.Types.Char] -> [GHC.Types.Char]
                                  <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                                = \ (ds :: [GHC.Types.Char]) ->
                                  case ds of wild1 {
                                    [] -> $j2
                                    : y ys
                                    -> case y of ww { GHC.Types.C# ww1 ->
                                       case GHC.Unicode.$wgeneralCategory ww1 of wild2 {
                                         DEFAULT -> go ys
                                         GHC.Unicode.UppercaseLetter -> Bob.responseFor5
                                         GHC.Unicode.LowercaseLetter -> Bob.responseFor5
                                         GHC.Unicode.TitlecaseLetter -> Bob.responseFor5
                                         GHC.Unicode.ModifierLetter -> Bob.responseFor5
                                         GHC.Unicode.OtherLetter -> Bob.responseFor5 } } }
                              } in
                              go xs }
                     } in
                     case (Bob.responseFor_go xs)
                            `cast`
                          (Data.Monoid.N:All[0]) of wild {
                       GHC.Types.False -> $j1
                       GHC.Types.True
                       -> letrec {
                            go :: [GHC.Types.Char] -> GHC.Types.Char -> [GHC.Types.Char]
                              <join 2> {- Arity: 2, Strictness: <S,1*U><L,1*U(1*U)> -}
                            = \ (ds :: [GHC.Types.Char]) (eta :: GHC.Types.Char) ->
                              case ds of wild1 {
                                []
                                -> case eta of wild2 { GHC.Types.C# x ->
                                   case x of wild3 {
                                     DEFAULT -> $j1
                                     '?'#
                                     -> letrec {
                                          go1 :: [GHC.Types.Char] -> [GHC.Types.Char]
                                            <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                                          = \ (ds1 :: [GHC.Types.Char]) ->
                                            case ds1 of wild4 {
                                              [] -> $j1
                                              : y ys
                                              -> case y of ww { GHC.Types.C# ww1 ->
                                                 case GHC.Unicode.$wgeneralCategory ww1 of wild5 {
                                                   DEFAULT -> go1 ys
                                                   GHC.Unicode.UppercaseLetter -> Bob.responseFor3
                                                   GHC.Unicode.LowercaseLetter -> Bob.responseFor3
                                                   GHC.Unicode.TitlecaseLetter -> Bob.responseFor3
                                                   GHC.Unicode.ModifierLetter -> Bob.responseFor3
                                                   GHC.Unicode.OtherLetter -> Bob.responseFor3 } } }
                                        } in
                                        go1 xs } }
                                : y ys -> go ys y }
                          } in
                          go (Bob.strip xs) (GHC.List.lastError @ GHC.Types.Char) }
                 } in
                 letrec {
                   go :: [GHC.Types.Char] -> [GHC.Types.Char]
                     <join 1> {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [GHC.Types.Char]) ->
                     case ds of wild {
                       [] -> Bob.responseFor1
                       : y ys
                       -> case y of ww { GHC.Types.C# ww1 ->
                          let {
                            x :: GHC.Prim.Word# = GHC.Prim.int2Word# (GHC.Prim.ord# ww1)
                          } in
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.leWord# x 887##) of wild1 {
                            GHC.Types.False
                            -> case {__pkg_ccall base-4.10.1.0 GHC.Prim.Int#
                                                               -> GHC.Prim.State# GHC.Prim.RealWorld
                                                               -> (# GHC.Prim.State#
                                                                       GHC.Prim.RealWorld,
                                                                     GHC.Prim.Int# #)}
                                      (GHC.Prim.ord# ww1)
                                      GHC.Prim.realWorld# of wild2 { (#,#) ds1 ds2 ->
                               case ds2 of wild3 { DEFAULT -> go ys 0# -> $j } }
                            GHC.Types.True
                            -> case x of wild2 {
                                 DEFAULT
                                 -> case GHC.Prim.tagToEnum#
                                           @ GHC.Types.Bool
                                           (GHC.Prim.leWord#
                                              (GHC.Prim.minusWord# wild2 9##)
                                              4##) of wild3 {
                                      GHC.Types.False
                                      -> case wild2 of wild4 { DEFAULT -> $j 160## -> go ys }
                                      GHC.Types.True -> go ys }
                                 32## -> go ys } } } }
                 } in
                 go xs) -}
f41e37dc3d76bbd136db4d9711943409
  responseFor1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Bob.responseFor2) -}
f7d6bc5d7c46e34045eac8a909605eee
  responseFor2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Fine. Be that way!"#) -}
8e522c5233d916a63a3c0bf9e956d11f
  responseFor3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Bob.responseFor4) -}
8e43943c376a4ddf666b28281eaed8be
  responseFor4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("Calm down, I know what I'm doing!"#) -}
7a89b56d260948a06de3db02c6a1dafc
  responseFor5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# Bob.responseFor6) -}
fd2b7010c08ebd7dce94afd155eaca61
  responseFor6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Whoa, chill out!"#) -}
2dfad1befe6e66de79e544a12883ab13
  responseFor_go :: [GHC.Types.Char] -> Data.Monoid.All
  {- Arity: 1, Strictness: <S,1*U> -}
4521aad166f1efa6fdfb38b928f1d8e1
  responseFor_go1 ::
    [GHC.Types.Char] -> GHC.Types.Char -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <S,1*U><L,1*U(1*U)> -}
7026f663f5aee49d43a05abc4f459d02
  strip :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (x :: [GHC.Types.Char]) ->
                 GHC.List.reverse1
                   @ GHC.Types.Char
                   (GHC.List.dropWhile
                      @ GHC.Types.Char
                      GHC.Unicode.isSpace
                      (GHC.List.reverse1
                         @ GHC.Types.Char
                         (GHC.List.dropWhile @ GHC.Types.Char GHC.Unicode.isSpace x)
                         (GHC.Types.[] @ GHC.Types.Char)))
                   (GHC.Types.[] @ GHC.Types.Char)) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

